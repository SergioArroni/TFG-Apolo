== Design Decisions

|===
|Decision|Details|Advantages|Disadvantages
|Internazionalization|We will develop the documentation in english and the application in english and spanish|With this internazionalization we improve accesibility a lot|Time can be a factor to consider and make two language internazionalization can use a lot of time
|Design architecture|We will use MVC as architectural pattern for backend and Redux for frontend|With MVC we have better usability and a very organized and understable code. Redux helps us with data synchrony|MVC: We need to structure the code perfectly to comply with the convention. Redux: We never used it. Instead we decided to use React Hooks like CreateContext or UseContext
|Frameworks|We used the React Hooks and functionalities in frontend, taking advantage of it's utilities because it is intuitive|We can use it to facilitate the implementation|Is a new technology to us so we need to improve our knowledge about it
|Data Base|We choosed MongoDB to store all the information|MongoDB allows us to make an easier implementation|Is a new technology to us so we need to improbe our kownledge about it
|Save images|We have decided to store all images related to the product catalogue in an external API called Cloudiary|With this we manage to decentralise the images of the project, the favourable implications are many, from increasing security, such as lightening the weight of the project by not having to save the images, also highlighting the ease of displaying them as it works through a URL saved in the product|The disadvantages are having to configure the entire API, the fact that the products have to save a URL increases its complexity, we depend on this external API for the correct functioning of the application
|Hexagonal architecture|At the beginning of the project we decided that the backend would be governed by a hexagonal architecture, this is due to the recommendation given by Professor Jose Emilio Labra Gayo in theory and because we had already worked with this|One of the advantages we found is that this project is for the subject of Software Architecture, so adding a hexagonal architecture to the project gives it more strength. Also, we have the intrinsic advantages of a hexagonal architecture, which are to decouple ourselves from the database, since the project does not care about the implementation of this, to focus more on the application domain, to decouple the layers of the backend, this leads to the fact that it was easier for us to perform unit tests and added modifications|As disadvantages, I would say that the main ones were that a large part of the project had to be redone, given by the teachers, and that not all the members knew how the architecture worked
|Docker Database|The decision to use a docker for the database was taken at the beginning of the project, this decision seemed natural to all of us at the beginning because if we had a docker for the frontend, another one for the backend, it made sense to make another one for the database. Although at the beginning we tried MongoAtlas to host our database, we didn't like to depend on an external service|This decision has many advantages in terms of architecture; we manage to reduce dependence on external services by taking care of the maintenance of the database as well as its deployment and configuration. The advantages of using microservices instead of using services provided by large companies have been widely discussed in class. We base ourselves on the recommendations given in theory on the use of microservices, as these manage to lower the coupling of the project, the use of individualised docker for each service gives us a freedom that we would not have in SOA, and also gives us greater speed when it comes to deployment|As disadvantages the most notable of all has been the complete lack of knowledge that we have of the use of microservices, we have generated quite a few headaches because not having the same approach as the rest of the groups we could not help each other, but we looked for a lot of information in forums and other websites, to get everything to work
|Seeding the database in Docker|Since we had the database in a separate docker, we decided to create another one to seed the database, it was decided to do it in python as it seemed the fastest to do, due to the simplicity of python|By having the database seeding isolated from the rest of the project, we make inserting data into it as easy as adding a line to the file, it is also good because we could use external python datasets to populate our model, this makes our project highly modifiable|One drawback we saw is that if you don't control in the database that there can be unique items by name (see controlling that no two products are the same), then you could not run the docker-compose several times as it would repeat data. It also complicates the task of getting it up on the web
|Distance Matrix API to calculate distances|We decided to use Distance Matrix API to calculate the distance between 2 streets|It gives us the distance by passing 2 addresses in string format|It doesn't give us the shipping price directly. We have to calculate it manually from the distance.
|Various databases|It was decided to create separate databases, one for backend unit tests, one for e2e unit tests, one for docker deployment and one for local deployment|With this we get low the level of coupling of the project, since each part of the project that needs the database, has a dedicated database for it, for example if in the unit tests we put a new user to register, this is not registered in the production database, nor in the unit tests, nor in the local tests. This was easier for us thanks to the hexagonal architecture, as we only had to touch on one file to create as many databases as we needed|There were not many problems with this decision, but if this were a large-scale project I suspect that having 4 databases instead of one would be more costly and difficult to maintain, but at our scale it only brought benefits
|MUI & Bootstrap| We used both libraries. MUI because of the facilities given by some of its components and bootstrap because of the easy way to style them any way we want|Both resources are compatible and easy to use and syncronize | When used both components at the sae time, sometimes they are not same-styled
|AWS|The decision to use AWS was practically not a decision, but a necessary decision given our resources and focus. By having 3 distinct dockers, we can no longer deploy for free on Heroku, as it is a cloud computing platform as a service that only allows 2 containers simultaneously for free. In Azure we had no credit, so we were left with ASW|A big advantage was the free credit and the good guidance of pglez82 which we followed step by step|We had a hard time getting our whole project to work on ASW, but I think we would have had the same problems on any other platform
|PBKDF2|We decided to increase the security of the project by using an asynchronous encryption algorithm such as PBKDF2|We decided on this one because we have taught it in another subject and we know how it works inside. Thanks to it we have managed to save our passwords encrypted, which considerably increases the security of the application|Changes had to be made in many parts of the project, especially in the backend, as the user entity had to be changed
|Login to SOLID POD|At the meridian of the project development, the decision was taken to use only the address of the user's SOLID PODs and not to do the whole login with SOLID. It should be noted that we do have a SOLID login, but this is optional, as we have seen that SOLID does not work as well as we would like, so we leave it up to the user to decide whether to log in to SOLID or just enter their SOLID username and we just take out the address|The main advantages are that we give the user more freedom when buying in our shop, we do not restrict the user to only have SOLID, also by having both options, if one of these does not work we have the other, thus increasing the solidity of the project|Doing the two options functions entailed double the work required for this part
|Bootswatch|We used bootswatch to give the bootsrap components a uniform style and also make the website style in a harmony where all components and colours match| I'ts super easy to use and makes you save a lot of work in CSS style sheets| MUI components are not affected so we had to style them manually
|SweetAlert2|We used this library to give the user intuitive and animated alerts while using the website |I'ts easy to use and comes with predeterminated settings that makes the programming experience a lot easier| I'ts another dependecy we had to take care of and make sure it doesn't overlap with anything else ceating bugs
|Work|One of the decisions taken was to prioritise the necessary functionalities and polish them, rather than make new ones optional|We were able to polish the functionalities we had, although we would have liked to polish them further|In the end we didn't manage to polish them at all and lost the option to make them optional
|react-material-ui-carousel|This library is used to make our home page a little bit more dynamic and beautiful. This is a library created with @mui components.| Very configurable and easy to use. It gives a very good result with little configuration.|Is another dependency that makes our proyect heavier and more dependent on external libraries. It also makes us to hardcode some code as images URLs and some texts.
|CSS|Used to make our application more beautiful and to make all pages elements stay in its positions.|Is a known language for some of our team members, so we can use it properly.|It makes you write more code and sometimes is difficult to make the styles in the proper way.
|===

